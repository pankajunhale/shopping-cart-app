{
  "version": 3,
  "sources": ["../../../../../node_modules/class-transformer/esm5/enums/transformation-type.enum.js", "../../../../../node_modules/class-transformer/esm5/MetadataStorage.js", "../../../../../node_modules/class-transformer/esm5/storage.js", "../../../../../node_modules/class-transformer/esm5/utils/get-global.util.js", "../../../../../node_modules/class-transformer/esm5/utils/is-promise.util.js", "../../../../../node_modules/class-transformer/esm5/TransformOperationExecutor.js", "../../../../../node_modules/class-transformer/esm5/constants/default-options.constant.js", "../../../../../node_modules/class-transformer/esm5/ClassTransformer.js", "../../../../../node_modules/class-transformer/esm5/decorators/exclude.decorator.js", "../../../../../node_modules/class-transformer/esm5/decorators/expose.decorator.js", "../../../../../node_modules/class-transformer/esm5/decorators/transform-instance-to-instance.decorator.js", "../../../../../node_modules/class-transformer/esm5/decorators/transform-instance-to-plain.decorator.js", "../../../../../node_modules/class-transformer/esm5/decorators/transform-plain-to-instance.decorator.js", "../../../../../node_modules/class-transformer/esm5/decorators/transform.decorator.js", "../../../../../node_modules/class-transformer/esm5/decorators/type.decorator.js", "../../../../../node_modules/class-transformer/esm5/index.js"],
  "sourcesContent": ["export var TransformationType;\n(function (TransformationType) {\n    TransformationType[TransformationType[\"PLAIN_TO_CLASS\"] = 0] = \"PLAIN_TO_CLASS\";\n    TransformationType[TransformationType[\"CLASS_TO_PLAIN\"] = 1] = \"CLASS_TO_PLAIN\";\n    TransformationType[TransformationType[\"CLASS_TO_CLASS\"] = 2] = \"CLASS_TO_CLASS\";\n})(TransformationType || (TransformationType = {}));\n", "import { TransformationType } from './enums';\n/**\n * Storage all library metadata.\n */\nvar MetadataStorage = /** @class */ (function () {\n    function MetadataStorage() {\n        // -------------------------------------------------------------------------\n        // Properties\n        // -------------------------------------------------------------------------\n        this._typeMetadatas = new Map();\n        this._transformMetadatas = new Map();\n        this._exposeMetadatas = new Map();\n        this._excludeMetadatas = new Map();\n        this._ancestorsMap = new Map();\n    }\n    // -------------------------------------------------------------------------\n    // Adder Methods\n    // -------------------------------------------------------------------------\n    MetadataStorage.prototype.addTypeMetadata = function (metadata) {\n        if (!this._typeMetadatas.has(metadata.target)) {\n            this._typeMetadatas.set(metadata.target, new Map());\n        }\n        this._typeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n    };\n    MetadataStorage.prototype.addTransformMetadata = function (metadata) {\n        if (!this._transformMetadatas.has(metadata.target)) {\n            this._transformMetadatas.set(metadata.target, new Map());\n        }\n        if (!this._transformMetadatas.get(metadata.target).has(metadata.propertyName)) {\n            this._transformMetadatas.get(metadata.target).set(metadata.propertyName, []);\n        }\n        this._transformMetadatas.get(metadata.target).get(metadata.propertyName).push(metadata);\n    };\n    MetadataStorage.prototype.addExposeMetadata = function (metadata) {\n        if (!this._exposeMetadatas.has(metadata.target)) {\n            this._exposeMetadatas.set(metadata.target, new Map());\n        }\n        this._exposeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n    };\n    MetadataStorage.prototype.addExcludeMetadata = function (metadata) {\n        if (!this._excludeMetadatas.has(metadata.target)) {\n            this._excludeMetadatas.set(metadata.target, new Map());\n        }\n        this._excludeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n    };\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    MetadataStorage.prototype.findTransformMetadatas = function (target, propertyName, transformationType) {\n        return this.findMetadatas(this._transformMetadatas, target, propertyName).filter(function (metadata) {\n            if (!metadata.options)\n                return true;\n            if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)\n                return true;\n            if (metadata.options.toClassOnly === true) {\n                return (transformationType === TransformationType.CLASS_TO_CLASS ||\n                    transformationType === TransformationType.PLAIN_TO_CLASS);\n            }\n            if (metadata.options.toPlainOnly === true) {\n                return transformationType === TransformationType.CLASS_TO_PLAIN;\n            }\n            return true;\n        });\n    };\n    MetadataStorage.prototype.findExcludeMetadata = function (target, propertyName) {\n        return this.findMetadata(this._excludeMetadatas, target, propertyName);\n    };\n    MetadataStorage.prototype.findExposeMetadata = function (target, propertyName) {\n        return this.findMetadata(this._exposeMetadatas, target, propertyName);\n    };\n    MetadataStorage.prototype.findExposeMetadataByCustomName = function (target, name) {\n        return this.getExposedMetadatas(target).find(function (metadata) {\n            return metadata.options && metadata.options.name === name;\n        });\n    };\n    MetadataStorage.prototype.findTypeMetadata = function (target, propertyName) {\n        return this.findMetadata(this._typeMetadatas, target, propertyName);\n    };\n    MetadataStorage.prototype.getStrategy = function (target) {\n        var excludeMap = this._excludeMetadatas.get(target);\n        var exclude = excludeMap && excludeMap.get(undefined);\n        var exposeMap = this._exposeMetadatas.get(target);\n        var expose = exposeMap && exposeMap.get(undefined);\n        if ((exclude && expose) || (!exclude && !expose))\n            return 'none';\n        return exclude ? 'excludeAll' : 'exposeAll';\n    };\n    MetadataStorage.prototype.getExposedMetadatas = function (target) {\n        return this.getMetadata(this._exposeMetadatas, target);\n    };\n    MetadataStorage.prototype.getExcludedMetadatas = function (target) {\n        return this.getMetadata(this._excludeMetadatas, target);\n    };\n    MetadataStorage.prototype.getExposedProperties = function (target, transformationType) {\n        return this.getExposedMetadatas(target)\n            .filter(function (metadata) {\n            if (!metadata.options)\n                return true;\n            if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)\n                return true;\n            if (metadata.options.toClassOnly === true) {\n                return (transformationType === TransformationType.CLASS_TO_CLASS ||\n                    transformationType === TransformationType.PLAIN_TO_CLASS);\n            }\n            if (metadata.options.toPlainOnly === true) {\n                return transformationType === TransformationType.CLASS_TO_PLAIN;\n            }\n            return true;\n        })\n            .map(function (metadata) { return metadata.propertyName; });\n    };\n    MetadataStorage.prototype.getExcludedProperties = function (target, transformationType) {\n        return this.getExcludedMetadatas(target)\n            .filter(function (metadata) {\n            if (!metadata.options)\n                return true;\n            if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)\n                return true;\n            if (metadata.options.toClassOnly === true) {\n                return (transformationType === TransformationType.CLASS_TO_CLASS ||\n                    transformationType === TransformationType.PLAIN_TO_CLASS);\n            }\n            if (metadata.options.toPlainOnly === true) {\n                return transformationType === TransformationType.CLASS_TO_PLAIN;\n            }\n            return true;\n        })\n            .map(function (metadata) { return metadata.propertyName; });\n    };\n    MetadataStorage.prototype.clear = function () {\n        this._typeMetadatas.clear();\n        this._exposeMetadatas.clear();\n        this._excludeMetadatas.clear();\n        this._ancestorsMap.clear();\n    };\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n    MetadataStorage.prototype.getMetadata = function (metadatas, target) {\n        var metadataFromTargetMap = metadatas.get(target);\n        var metadataFromTarget;\n        if (metadataFromTargetMap) {\n            metadataFromTarget = Array.from(metadataFromTargetMap.values()).filter(function (meta) { return meta.propertyName !== undefined; });\n        }\n        var metadataFromAncestors = [];\n        for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {\n            var ancestor = _a[_i];\n            var ancestorMetadataMap = metadatas.get(ancestor);\n            if (ancestorMetadataMap) {\n                var metadataFromAncestor = Array.from(ancestorMetadataMap.values()).filter(function (meta) { return meta.propertyName !== undefined; });\n                metadataFromAncestors.push.apply(metadataFromAncestors, metadataFromAncestor);\n            }\n        }\n        return metadataFromAncestors.concat(metadataFromTarget || []);\n    };\n    MetadataStorage.prototype.findMetadata = function (metadatas, target, propertyName) {\n        var metadataFromTargetMap = metadatas.get(target);\n        if (metadataFromTargetMap) {\n            var metadataFromTarget = metadataFromTargetMap.get(propertyName);\n            if (metadataFromTarget) {\n                return metadataFromTarget;\n            }\n        }\n        for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {\n            var ancestor = _a[_i];\n            var ancestorMetadataMap = metadatas.get(ancestor);\n            if (ancestorMetadataMap) {\n                var ancestorResult = ancestorMetadataMap.get(propertyName);\n                if (ancestorResult) {\n                    return ancestorResult;\n                }\n            }\n        }\n        return undefined;\n    };\n    MetadataStorage.prototype.findMetadatas = function (metadatas, target, propertyName) {\n        var metadataFromTargetMap = metadatas.get(target);\n        var metadataFromTarget;\n        if (metadataFromTargetMap) {\n            metadataFromTarget = metadataFromTargetMap.get(propertyName);\n        }\n        var metadataFromAncestorsTarget = [];\n        for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {\n            var ancestor = _a[_i];\n            var ancestorMetadataMap = metadatas.get(ancestor);\n            if (ancestorMetadataMap) {\n                if (ancestorMetadataMap.has(propertyName)) {\n                    metadataFromAncestorsTarget.push.apply(metadataFromAncestorsTarget, ancestorMetadataMap.get(propertyName));\n                }\n            }\n        }\n        return metadataFromAncestorsTarget\n            .slice()\n            .reverse()\n            .concat((metadataFromTarget || []).slice().reverse());\n    };\n    MetadataStorage.prototype.getAncestors = function (target) {\n        if (!target)\n            return [];\n        if (!this._ancestorsMap.has(target)) {\n            var ancestors = [];\n            for (var baseClass = Object.getPrototypeOf(target.prototype.constructor); typeof baseClass.prototype !== 'undefined'; baseClass = Object.getPrototypeOf(baseClass.prototype.constructor)) {\n                ancestors.push(baseClass);\n            }\n            this._ancestorsMap.set(target, ancestors);\n        }\n        return this._ancestorsMap.get(target);\n    };\n    return MetadataStorage;\n}());\nexport { MetadataStorage };\n", "import { MetadataStorage } from './MetadataStorage';\n/**\n * Default metadata storage is used as singleton and can be used to storage all metadatas.\n */\nexport var defaultMetadataStorage = new MetadataStorage();\n", "/**\n * This function returns the global object across Node and browsers.\n *\n * Note: `globalThis` is the standardized approach however it has been added to\n * Node.js in version 12. We need to include this snippet until Node 12 EOL.\n */\nexport function getGlobal() {\n    if (typeof globalThis !== 'undefined') {\n        return globalThis;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore: Cannot find name 'window'.\n    if (typeof window !== 'undefined') {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore: Cannot find name 'window'.\n        return window;\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore: Cannot find name 'self'.\n    if (typeof self !== 'undefined') {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore: Cannot find name 'self'.\n        return self;\n    }\n}\n", "export function isPromise(p) {\n    return p !== null && typeof p === 'object' && typeof p.then === 'function';\n}\n", "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { defaultMetadataStorage } from './storage';\nimport { TransformationType } from './enums';\nimport { getGlobal, isPromise } from './utils';\nfunction instantiateArrayType(arrayType) {\n    var array = new arrayType();\n    if (!(array instanceof Set) && !('push' in array)) {\n        return [];\n    }\n    return array;\n}\nvar TransformOperationExecutor = /** @class */ (function () {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    function TransformOperationExecutor(transformationType, options) {\n        this.transformationType = transformationType;\n        this.options = options;\n        // -------------------------------------------------------------------------\n        // Private Properties\n        // -------------------------------------------------------------------------\n        this.recursionStack = new Set();\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    TransformOperationExecutor.prototype.transform = function (source, value, targetType, arrayType, isMap, level) {\n        var _this = this;\n        if (level === void 0) { level = 0; }\n        if (Array.isArray(value) || value instanceof Set) {\n            var newValue_1 = arrayType && this.transformationType === TransformationType.PLAIN_TO_CLASS\n                ? instantiateArrayType(arrayType)\n                : [];\n            value.forEach(function (subValue, index) {\n                var subSource = source ? source[index] : undefined;\n                if (!_this.options.enableCircularCheck || !_this.isCircular(subValue)) {\n                    var realTargetType = void 0;\n                    if (typeof targetType !== 'function' &&\n                        targetType &&\n                        targetType.options &&\n                        targetType.options.discriminator &&\n                        targetType.options.discriminator.property &&\n                        targetType.options.discriminator.subTypes) {\n                        if (_this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                            realTargetType = targetType.options.discriminator.subTypes.find(function (subType) {\n                                return subType.name === subValue[targetType.options.discriminator.property];\n                            });\n                            var options = { newObject: newValue_1, object: subValue, property: undefined };\n                            var newType = targetType.typeFunction(options);\n                            realTargetType === undefined ? (realTargetType = newType) : (realTargetType = realTargetType.value);\n                            if (!targetType.options.keepDiscriminatorProperty)\n                                delete subValue[targetType.options.discriminator.property];\n                        }\n                        if (_this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                            realTargetType = subValue.constructor;\n                        }\n                        if (_this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n                            subValue[targetType.options.discriminator.property] = targetType.options.discriminator.subTypes.find(function (subType) { return subType.value === subValue.constructor; }).name;\n                        }\n                    }\n                    else {\n                        realTargetType = targetType;\n                    }\n                    var value_1 = _this.transform(subSource, subValue, realTargetType, undefined, subValue instanceof Map, level + 1);\n                    if (newValue_1 instanceof Set) {\n                        newValue_1.add(value_1);\n                    }\n                    else {\n                        newValue_1.push(value_1);\n                    }\n                }\n                else if (_this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                    if (newValue_1 instanceof Set) {\n                        newValue_1.add(subValue);\n                    }\n                    else {\n                        newValue_1.push(subValue);\n                    }\n                }\n            });\n            return newValue_1;\n        }\n        else if (targetType === String && !isMap) {\n            if (value === null || value === undefined)\n                return value;\n            return String(value);\n        }\n        else if (targetType === Number && !isMap) {\n            if (value === null || value === undefined)\n                return value;\n            return Number(value);\n        }\n        else if (targetType === Boolean && !isMap) {\n            if (value === null || value === undefined)\n                return value;\n            return Boolean(value);\n        }\n        else if ((targetType === Date || value instanceof Date) && !isMap) {\n            if (value instanceof Date) {\n                return new Date(value.valueOf());\n            }\n            if (value === null || value === undefined)\n                return value;\n            return new Date(value);\n        }\n        else if (!!getGlobal().Buffer && (targetType === Buffer || value instanceof Buffer) && !isMap) {\n            if (value === null || value === undefined)\n                return value;\n            return Buffer.from(value);\n        }\n        else if (isPromise(value) && !isMap) {\n            return new Promise(function (resolve, reject) {\n                value.then(function (data) { return resolve(_this.transform(undefined, data, targetType, undefined, undefined, level + 1)); }, reject);\n            });\n        }\n        else if (!isMap && value !== null && typeof value === 'object' && typeof value.then === 'function') {\n            // Note: We should not enter this, as promise has been handled above\n            // This option simply returns the Promise preventing a JS error from happening and should be an inaccessible path.\n            return value; // skip promise transformation\n        }\n        else if (typeof value === 'object' && value !== null) {\n            // try to guess the type\n            if (!targetType && value.constructor !== Object /* && TransformationType === TransformationType.CLASS_TO_PLAIN*/)\n                if (!Array.isArray(value) && value.constructor === Array) {\n                    // Somebody attempts to convert special Array like object to Array, eg:\n                    // const evilObject = { '100000000': '100000000', __proto__: [] };\n                    // This could be used to cause Denial-of-service attack so we don't allow it.\n                    // See prevent-array-bomb.spec.ts for more details.\n                }\n                else {\n                    // We are good we can use the built-in constructor\n                    targetType = value.constructor;\n                }\n            if (!targetType && source)\n                targetType = source.constructor;\n            if (this.options.enableCircularCheck) {\n                // add transformed type to prevent circular references\n                this.recursionStack.add(value);\n            }\n            var keys = this.getKeys(targetType, value, isMap);\n            var newValue = source ? source : {};\n            if (!source &&\n                (this.transformationType === TransformationType.PLAIN_TO_CLASS ||\n                    this.transformationType === TransformationType.CLASS_TO_CLASS)) {\n                if (isMap) {\n                    newValue = new Map();\n                }\n                else if (targetType) {\n                    newValue = new targetType();\n                }\n                else {\n                    newValue = {};\n                }\n            }\n            var _loop_1 = function (key) {\n                if (key === '__proto__' || key === 'constructor') {\n                    return \"continue\";\n                }\n                var valueKey = key;\n                var newValueKey = key, propertyName = key;\n                if (!this_1.options.ignoreDecorators && targetType) {\n                    if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                        var exposeMetadata = defaultMetadataStorage.findExposeMetadataByCustomName(targetType, key);\n                        if (exposeMetadata) {\n                            propertyName = exposeMetadata.propertyName;\n                            newValueKey = exposeMetadata.propertyName;\n                        }\n                    }\n                    else if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN ||\n                        this_1.transformationType === TransformationType.CLASS_TO_CLASS) {\n                        var exposeMetadata = defaultMetadataStorage.findExposeMetadata(targetType, key);\n                        if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\n                            newValueKey = exposeMetadata.options.name;\n                        }\n                    }\n                }\n                // get a subvalue\n                var subValue = undefined;\n                if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                    /**\n                     * This section is added for the following report:\n                     * https://github.com/typestack/class-transformer/issues/596\n                     *\n                     * We should not call functions or constructors when transforming to class.\n                     */\n                    subValue = value[valueKey];\n                }\n                else {\n                    if (value instanceof Map) {\n                        subValue = value.get(valueKey);\n                    }\n                    else if (value[valueKey] instanceof Function) {\n                        subValue = value[valueKey]();\n                    }\n                    else {\n                        subValue = value[valueKey];\n                    }\n                }\n                // determine a type\n                var type = undefined, isSubValueMap = subValue instanceof Map;\n                if (targetType && isMap) {\n                    type = targetType;\n                }\n                else if (targetType) {\n                    var metadata_1 = defaultMetadataStorage.findTypeMetadata(targetType, propertyName);\n                    if (metadata_1) {\n                        var options = { newObject: newValue, object: value, property: propertyName };\n                        var newType = metadata_1.typeFunction ? metadata_1.typeFunction(options) : metadata_1.reflectedType;\n                        if (metadata_1.options &&\n                            metadata_1.options.discriminator &&\n                            metadata_1.options.discriminator.property &&\n                            metadata_1.options.discriminator.subTypes) {\n                            if (!(value[valueKey] instanceof Array)) {\n                                if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                                    type = metadata_1.options.discriminator.subTypes.find(function (subType) {\n                                        if (subValue && subValue instanceof Object && metadata_1.options.discriminator.property in subValue) {\n                                            return subType.name === subValue[metadata_1.options.discriminator.property];\n                                        }\n                                    });\n                                    type === undefined ? (type = newType) : (type = type.value);\n                                    if (!metadata_1.options.keepDiscriminatorProperty) {\n                                        if (subValue && subValue instanceof Object && metadata_1.options.discriminator.property in subValue) {\n                                            delete subValue[metadata_1.options.discriminator.property];\n                                        }\n                                    }\n                                }\n                                if (this_1.transformationType === TransformationType.CLASS_TO_CLASS) {\n                                    type = subValue.constructor;\n                                }\n                                if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN) {\n                                    if (subValue) {\n                                        subValue[metadata_1.options.discriminator.property] = metadata_1.options.discriminator.subTypes.find(function (subType) { return subType.value === subValue.constructor; }).name;\n                                    }\n                                }\n                            }\n                            else {\n                                type = metadata_1;\n                            }\n                        }\n                        else {\n                            type = newType;\n                        }\n                        isSubValueMap = isSubValueMap || metadata_1.reflectedType === Map;\n                    }\n                    else if (this_1.options.targetMaps) {\n                        // try to find a type in target maps\n                        this_1.options.targetMaps\n                            .filter(function (map) { return map.target === targetType && !!map.properties[propertyName]; })\n                            .forEach(function (map) { return (type = map.properties[propertyName]); });\n                    }\n                    else if (this_1.options.enableImplicitConversion &&\n                        this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                        // if we have no registererd type via the @Type() decorator then we check if we have any\n                        // type declarations in reflect-metadata (type declaration is emited only if some decorator is added to the property.)\n                        var reflectedType = Reflect.getMetadata('design:type', targetType.prototype, propertyName);\n                        if (reflectedType) {\n                            type = reflectedType;\n                        }\n                    }\n                }\n                // if value is an array try to get its custom array type\n                var arrayType_1 = Array.isArray(value[valueKey])\n                    ? this_1.getReflectedType(targetType, propertyName)\n                    : undefined;\n                // const subValueKey = TransformationType === TransformationType.PLAIN_TO_CLASS && newKeyName ? newKeyName : key;\n                var subSource = source ? source[valueKey] : undefined;\n                // if its deserialization then type if required\n                // if we uncomment this types like string[] will not work\n                // if (this.transformationType === TransformationType.PLAIN_TO_CLASS && !type && subValue instanceof Object && !(subValue instanceof Date))\n                //     throw new Error(`Cannot determine type for ${(targetType as any).name }.${propertyName}, did you forget to specify a @Type?`);\n                // if newValue is a source object that has method that match newKeyName then skip it\n                if (newValue.constructor.prototype) {\n                    var descriptor = Object.getOwnPropertyDescriptor(newValue.constructor.prototype, newValueKey);\n                    if ((this_1.transformationType === TransformationType.PLAIN_TO_CLASS ||\n                        this_1.transformationType === TransformationType.CLASS_TO_CLASS) &&\n                        // eslint-disable-next-line @typescript-eslint/unbound-method\n                        ((descriptor && !descriptor.set) || newValue[newValueKey] instanceof Function))\n                        return \"continue\";\n                }\n                if (!this_1.options.enableCircularCheck || !this_1.isCircular(subValue)) {\n                    var transformKey = this_1.transformationType === TransformationType.PLAIN_TO_CLASS ? newValueKey : key;\n                    var finalValue = void 0;\n                    if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN) {\n                        // Get original value\n                        finalValue = value[transformKey];\n                        // Apply custom transformation\n                        finalValue = this_1.applyCustomTransformations(finalValue, targetType, transformKey, value, this_1.transformationType);\n                        // If nothing change, it means no custom transformation was applied, so use the subValue.\n                        finalValue = value[transformKey] === finalValue ? subValue : finalValue;\n                        // Apply the default transformation\n                        finalValue = this_1.transform(subSource, finalValue, type, arrayType_1, isSubValueMap, level + 1);\n                    }\n                    else {\n                        if (subValue === undefined && this_1.options.exposeDefaultValues) {\n                            // Set default value if nothing provided\n                            finalValue = newValue[newValueKey];\n                        }\n                        else {\n                            finalValue = this_1.transform(subSource, subValue, type, arrayType_1, isSubValueMap, level + 1);\n                            finalValue = this_1.applyCustomTransformations(finalValue, targetType, transformKey, value, this_1.transformationType);\n                        }\n                    }\n                    if (finalValue !== undefined || this_1.options.exposeUnsetFields) {\n                        if (newValue instanceof Map) {\n                            newValue.set(newValueKey, finalValue);\n                        }\n                        else {\n                            newValue[newValueKey] = finalValue;\n                        }\n                    }\n                }\n                else if (this_1.transformationType === TransformationType.CLASS_TO_CLASS) {\n                    var finalValue = subValue;\n                    finalValue = this_1.applyCustomTransformations(finalValue, targetType, key, value, this_1.transformationType);\n                    if (finalValue !== undefined || this_1.options.exposeUnsetFields) {\n                        if (newValue instanceof Map) {\n                            newValue.set(newValueKey, finalValue);\n                        }\n                        else {\n                            newValue[newValueKey] = finalValue;\n                        }\n                    }\n                }\n            };\n            var this_1 = this;\n            // traverse over keys\n            for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n                var key = keys_1[_i];\n                _loop_1(key);\n            }\n            if (this.options.enableCircularCheck) {\n                this.recursionStack.delete(value);\n            }\n            return newValue;\n        }\n        else {\n            return value;\n        }\n    };\n    TransformOperationExecutor.prototype.applyCustomTransformations = function (value, target, key, obj, transformationType) {\n        var _this = this;\n        var metadatas = defaultMetadataStorage.findTransformMetadatas(target, key, this.transformationType);\n        // apply versioning options\n        if (this.options.version !== undefined) {\n            metadatas = metadatas.filter(function (metadata) {\n                if (!metadata.options)\n                    return true;\n                return _this.checkVersion(metadata.options.since, metadata.options.until);\n            });\n        }\n        // apply grouping options\n        if (this.options.groups && this.options.groups.length) {\n            metadatas = metadatas.filter(function (metadata) {\n                if (!metadata.options)\n                    return true;\n                return _this.checkGroups(metadata.options.groups);\n            });\n        }\n        else {\n            metadatas = metadatas.filter(function (metadata) {\n                return !metadata.options || !metadata.options.groups || !metadata.options.groups.length;\n            });\n        }\n        metadatas.forEach(function (metadata) {\n            value = metadata.transformFn({ value: value, key: key, obj: obj, type: transformationType, options: _this.options });\n        });\n        return value;\n    };\n    // preventing circular references\n    TransformOperationExecutor.prototype.isCircular = function (object) {\n        return this.recursionStack.has(object);\n    };\n    TransformOperationExecutor.prototype.getReflectedType = function (target, propertyName) {\n        if (!target)\n            return undefined;\n        var meta = defaultMetadataStorage.findTypeMetadata(target, propertyName);\n        return meta ? meta.reflectedType : undefined;\n    };\n    TransformOperationExecutor.prototype.getKeys = function (target, object, isMap) {\n        var _this = this;\n        // determine exclusion strategy\n        var strategy = defaultMetadataStorage.getStrategy(target);\n        if (strategy === 'none')\n            strategy = this.options.strategy || 'exposeAll'; // exposeAll is default strategy\n        // get all keys that need to expose\n        var keys = [];\n        if (strategy === 'exposeAll' || isMap) {\n            if (object instanceof Map) {\n                keys = Array.from(object.keys());\n            }\n            else {\n                keys = Object.keys(object);\n            }\n        }\n        if (isMap) {\n            // expose & exclude do not apply for map keys only to fields\n            return keys;\n        }\n        /**\n         * If decorators are ignored but we don't want the extraneous values, then we use the\n         * metadata to decide which property is needed, but doesn't apply the decorator effect.\n         */\n        if (this.options.ignoreDecorators && this.options.excludeExtraneousValues && target) {\n            var exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);\n            var excludedProperties = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);\n            keys = __spreadArray(__spreadArray([], exposedProperties, true), excludedProperties, true);\n        }\n        if (!this.options.ignoreDecorators && target) {\n            // add all exposed to list of keys\n            var exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);\n            if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                exposedProperties = exposedProperties.map(function (key) {\n                    var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n                    if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\n                        return exposeMetadata.options.name;\n                    }\n                    return key;\n                });\n            }\n            if (this.options.excludeExtraneousValues) {\n                keys = exposedProperties;\n            }\n            else {\n                keys = keys.concat(exposedProperties);\n            }\n            // exclude excluded properties\n            var excludedProperties_1 = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);\n            if (excludedProperties_1.length > 0) {\n                keys = keys.filter(function (key) {\n                    return !excludedProperties_1.includes(key);\n                });\n            }\n            // apply versioning options\n            if (this.options.version !== undefined) {\n                keys = keys.filter(function (key) {\n                    var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n                    if (!exposeMetadata || !exposeMetadata.options)\n                        return true;\n                    return _this.checkVersion(exposeMetadata.options.since, exposeMetadata.options.until);\n                });\n            }\n            // apply grouping options\n            if (this.options.groups && this.options.groups.length) {\n                keys = keys.filter(function (key) {\n                    var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n                    if (!exposeMetadata || !exposeMetadata.options)\n                        return true;\n                    return _this.checkGroups(exposeMetadata.options.groups);\n                });\n            }\n            else {\n                keys = keys.filter(function (key) {\n                    var exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n                    return (!exposeMetadata ||\n                        !exposeMetadata.options ||\n                        !exposeMetadata.options.groups ||\n                        !exposeMetadata.options.groups.length);\n                });\n            }\n        }\n        // exclude prefixed properties\n        if (this.options.excludePrefixes && this.options.excludePrefixes.length) {\n            keys = keys.filter(function (key) {\n                return _this.options.excludePrefixes.every(function (prefix) {\n                    return key.substr(0, prefix.length) !== prefix;\n                });\n            });\n        }\n        // make sure we have unique keys\n        keys = keys.filter(function (key, index, self) {\n            return self.indexOf(key) === index;\n        });\n        return keys;\n    };\n    TransformOperationExecutor.prototype.checkVersion = function (since, until) {\n        var decision = true;\n        if (decision && since)\n            decision = this.options.version >= since;\n        if (decision && until)\n            decision = this.options.version < until;\n        return decision;\n    };\n    TransformOperationExecutor.prototype.checkGroups = function (groups) {\n        if (!groups)\n            return true;\n        return this.options.groups.some(function (optionGroup) { return groups.includes(optionGroup); });\n    };\n    return TransformOperationExecutor;\n}());\nexport { TransformOperationExecutor };\n", "/**\n * These are the default options used by any transformation operation.\n */\nexport var defaultOptions = {\n    enableCircularCheck: false,\n    enableImplicitConversion: false,\n    excludeExtraneousValues: false,\n    excludePrefixes: undefined,\n    exposeDefaultValues: false,\n    exposeUnsetFields: true,\n    groups: undefined,\n    ignoreDecorators: false,\n    strategy: undefined,\n    targetMaps: undefined,\n    version: undefined,\n};\n", "var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { TransformOperationExecutor } from './TransformOperationExecutor';\nimport { TransformationType } from './enums';\nimport { defaultOptions } from './constants/default-options.constant';\nvar ClassTransformer = /** @class */ (function () {\n    function ClassTransformer() {\n    }\n    ClassTransformer.prototype.instanceToPlain = function (object, options) {\n        var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, __assign(__assign({}, defaultOptions), options));\n        return executor.transform(undefined, object, undefined, undefined, undefined, undefined);\n    };\n    ClassTransformer.prototype.classToPlainFromExist = function (object, plainObject, options) {\n        var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, __assign(__assign({}, defaultOptions), options));\n        return executor.transform(plainObject, object, undefined, undefined, undefined, undefined);\n    };\n    ClassTransformer.prototype.plainToInstance = function (cls, plain, options) {\n        var executor = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, __assign(__assign({}, defaultOptions), options));\n        return executor.transform(undefined, plain, cls, undefined, undefined, undefined);\n    };\n    ClassTransformer.prototype.plainToClassFromExist = function (clsObject, plain, options) {\n        var executor = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, __assign(__assign({}, defaultOptions), options));\n        return executor.transform(clsObject, plain, undefined, undefined, undefined, undefined);\n    };\n    ClassTransformer.prototype.instanceToInstance = function (object, options) {\n        var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, __assign(__assign({}, defaultOptions), options));\n        return executor.transform(undefined, object, undefined, undefined, undefined, undefined);\n    };\n    ClassTransformer.prototype.classToClassFromExist = function (object, fromObject, options) {\n        var executor = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, __assign(__assign({}, defaultOptions), options));\n        return executor.transform(fromObject, object, undefined, undefined, undefined, undefined);\n    };\n    ClassTransformer.prototype.serialize = function (object, options) {\n        return JSON.stringify(this.instanceToPlain(object, options));\n    };\n    /**\n     * Deserializes given JSON string to a object of the given class.\n     */\n    ClassTransformer.prototype.deserialize = function (cls, json, options) {\n        var jsonObject = JSON.parse(json);\n        return this.plainToInstance(cls, jsonObject, options);\n    };\n    /**\n     * Deserializes given JSON string to an array of objects of the given class.\n     */\n    ClassTransformer.prototype.deserializeArray = function (cls, json, options) {\n        var jsonObject = JSON.parse(json);\n        return this.plainToInstance(cls, jsonObject, options);\n    };\n    return ClassTransformer;\n}());\nexport { ClassTransformer };\n", "import { defaultMetadataStorage } from '../storage';\n/**\n * Marks the given class or property as excluded. By default the property is excluded in both\n * constructorToPlain and plainToConstructor transformations. It can be limited to only one direction\n * via using the `toPlainOnly` or `toClassOnly` option.\n *\n * Can be applied to class definitions and properties.\n */\nexport function Exclude(options) {\n    if (options === void 0) { options = {}; }\n    /**\n     * NOTE: The `propertyName` property must be marked as optional because\n     * this decorator used both as a class and a property decorator and the\n     * Typescript compiler will freak out if we make it mandatory as a class\n     * decorator only receives one parameter.\n     */\n    return function (object, propertyName) {\n        defaultMetadataStorage.addExcludeMetadata({\n            target: object instanceof Function ? object : object.constructor,\n            propertyName: propertyName,\n            options: options,\n        });\n    };\n}\n", "import { defaultMetadataStorage } from '../storage';\n/**\n * Marks the given class or property as included. By default the property is included in both\n * constructorToPlain and plainToConstructor transformations. It can be limited to only one direction\n * via using the `toPlainOnly` or `toClassOnly` option.\n *\n * Can be applied to class definitions and properties.\n */\nexport function Expose(options) {\n    if (options === void 0) { options = {}; }\n    /**\n     * NOTE: The `propertyName` property must be marked as optional because\n     * this decorator used both as a class and a property decorator and the\n     * Typescript compiler will freak out if we make it mandatory as a class\n     * decorator only receives one parameter.\n     */\n    return function (object, propertyName) {\n        defaultMetadataStorage.addExposeMetadata({\n            target: object instanceof Function ? object : object.constructor,\n            propertyName: propertyName,\n            options: options,\n        });\n    };\n}\n", "import { ClassTransformer } from '../ClassTransformer';\n/**\n * Return the class instance only with the exposed properties.\n *\n * Can be applied to functions and getters/setters only.\n */\nexport function TransformInstanceToInstance(params) {\n    return function (target, propertyKey, descriptor) {\n        var classTransformer = new ClassTransformer();\n        var originalMethod = descriptor.value;\n        descriptor.value = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var result = originalMethod.apply(this, args);\n            var isPromise = !!result && (typeof result === 'object' || typeof result === 'function') && typeof result.then === 'function';\n            return isPromise\n                ? result.then(function (data) { return classTransformer.instanceToInstance(data, params); })\n                : classTransformer.instanceToInstance(result, params);\n        };\n    };\n}\n", "import { ClassTransformer } from '../ClassTransformer';\n/**\n * Transform the object from class to plain object and return only with the exposed properties.\n *\n * Can be applied to functions and getters/setters only.\n */\nexport function TransformInstanceToPlain(params) {\n    return function (target, propertyKey, descriptor) {\n        var classTransformer = new ClassTransformer();\n        var originalMethod = descriptor.value;\n        descriptor.value = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var result = originalMethod.apply(this, args);\n            var isPromise = !!result && (typeof result === 'object' || typeof result === 'function') && typeof result.then === 'function';\n            return isPromise\n                ? result.then(function (data) { return classTransformer.instanceToPlain(data, params); })\n                : classTransformer.instanceToPlain(result, params);\n        };\n    };\n}\n", "import { ClassTransformer } from '../ClassTransformer';\n/**\n * Return the class instance only with the exposed properties.\n *\n * Can be applied to functions and getters/setters only.\n */\nexport function TransformPlainToInstance(classType, params) {\n    return function (target, propertyKey, descriptor) {\n        var classTransformer = new ClassTransformer();\n        var originalMethod = descriptor.value;\n        descriptor.value = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var result = originalMethod.apply(this, args);\n            var isPromise = !!result && (typeof result === 'object' || typeof result === 'function') && typeof result.then === 'function';\n            return isPromise\n                ? result.then(function (data) { return classTransformer.plainToInstance(classType, data, params); })\n                : classTransformer.plainToInstance(classType, result, params);\n        };\n    };\n}\n", "import { defaultMetadataStorage } from '../storage';\n/**\n * Defines a custom logic for value transformation.\n *\n * Can be applied to properties only.\n */\nexport function Transform(transformFn, options) {\n    if (options === void 0) { options = {}; }\n    return function (target, propertyName) {\n        defaultMetadataStorage.addTransformMetadata({\n            target: target.constructor,\n            propertyName: propertyName,\n            transformFn: transformFn,\n            options: options,\n        });\n    };\n}\n", "import { defaultMetadataStorage } from '../storage';\n/**\n * Specifies a type of the property.\n * The given TypeFunction can return a constructor. A discriminator can be given in the options.\n *\n * Can be applied to properties only.\n */\nexport function Type(typeFunction, options) {\n    if (options === void 0) { options = {}; }\n    return function (target, propertyName) {\n        var reflectedType = Reflect.getMetadata('design:type', target, propertyName);\n        defaultMetadataStorage.addTypeMetadata({\n            target: target.constructor,\n            propertyName: propertyName,\n            reflectedType: reflectedType,\n            typeFunction: typeFunction,\n            options: options,\n        });\n    };\n}\n", "import { ClassTransformer } from './ClassTransformer';\nexport { ClassTransformer } from './ClassTransformer';\nexport * from './decorators';\nexport * from './interfaces';\nexport * from './enums';\nvar classTransformer = new ClassTransformer();\nexport function classToPlain(object, options) {\n    return classTransformer.instanceToPlain(object, options);\n}\nexport function instanceToPlain(object, options) {\n    return classTransformer.instanceToPlain(object, options);\n}\nexport function classToPlainFromExist(object, plainObject, options) {\n    return classTransformer.classToPlainFromExist(object, plainObject, options);\n}\nexport function plainToClass(cls, plain, options) {\n    return classTransformer.plainToInstance(cls, plain, options);\n}\nexport function plainToInstance(cls, plain, options) {\n    return classTransformer.plainToInstance(cls, plain, options);\n}\nexport function plainToClassFromExist(clsObject, plain, options) {\n    return classTransformer.plainToClassFromExist(clsObject, plain, options);\n}\nexport function instanceToInstance(object, options) {\n    return classTransformer.instanceToInstance(object, options);\n}\nexport function classToClassFromExist(object, fromObject, options) {\n    return classTransformer.classToClassFromExist(object, fromObject, options);\n}\nexport function serialize(object, options) {\n    return classTransformer.serialize(object, options);\n}\n/**\n * Deserializes given JSON string to a object of the given class.\n *\n * @deprecated This function is being removed. Please use the following instead:\n * ```\n * instanceToClass(cls, JSON.parse(json), options)\n * ```\n */\nexport function deserialize(cls, json, options) {\n    return classTransformer.deserialize(cls, json, options);\n}\n/**\n * Deserializes given JSON string to an array of objects of the given class.\n *\n * @deprecated This function is being removed. Please use the following instead:\n * ```\n * JSON.parse(json).map(value => instanceToClass(cls, value, options))\n * ```\n *\n */\nexport function deserializeArray(cls, json, options) {\n    return classTransformer.deserializeArray(cls, json, options);\n}\n"],
  "mappings": "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",
  "names": ["TransformationType", "MetadataStorage", "TransformOperationExecutor", "key", "self", "ClassTransformer", "classTransformer", "isPromise", "classTransformer", "isPromise", "classTransformer", "isPromise"]
}
